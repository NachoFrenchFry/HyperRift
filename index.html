<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HyperRift â€” Pixel-perfect (integer scaling)</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000; /* black bars around the canvas */
      -webkit-font-smoothing: none;
      -moz-osx-font-smoothing: grayscale;
    }
    /* Canvas displayed centered, but actual sizing is done via attributes to avoid CSS scaling */
    #screen {
      display: block;
      margin: 0;
      background: #000;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      image-rendering: pixelated; /* helps some browsers use nearest-neighbor for upscaling */
      image-rendering: crisp-edges;
    }
    #loading {
      position: absolute;
      left: 12px;
      top: 12px;
      color: #0ff;
      background: rgba(0,0,0,0.6);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="screen"></canvas>
  <div id="loading">Loading assets...</div>

<script>
/*
  Pixel-perfect HTML port (integer scaling)
  - Renders the game to an offscreen buffer at native 1200x800 resolution.
  - Chooses the largest integer scale factor (1,2,3,...) that fits the browser window.
  - Centers the scaled image and leaves black bars around it.
  - Disables smoothing and uses nearest-neighbor.
  - Uses the same file paths for textures as your C++ code.
*/

/* Constants (same as C++) */
const GAME_W = 1200;
const GAME_H = 800;
const SCREEN_WM = GAME_W / 2;
const SCREEN_HM = GAME_H / 2;

const PLAYER_W = 16 * 2;
const PLAYER_H = 22 * 2;

const GRAVITY = 0.7;
const ACCELERATION = 1.5;
const FRICTION = 0.91;

/* Canvas and contexts */
const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d', { alpha: false });
ctx.imageSmoothingEnabled = false;

// Offscreen buffer at native resolution
const buffer = document.createElement('canvas');
buffer.width = GAME_W;
buffer.height = GAME_H;
const g = buffer.getContext('2d', { alpha: false });
g.imageSmoothingEnabled = false;

// Attempt vendor-prefixed flags too
function disableSmoothing(targetCtx) {
  if (!targetCtx) return;
  targetCtx.imageSmoothingEnabled = false;
  targetCtx.mozImageSmoothingEnabled = false;
  targetCtx.webkitImageSmoothingEnabled = false;
  targetCtx.msImageSmoothingEnabled = false;
}
disableSmoothing(ctx);
disableSmoothing(g);

/* Layout variables for integer scaling */
let scale = 1;     // integer scale factor
let destW = GAME_W;
let destH = GAME_H;
let destX = 0;
let destY = 0;

function computeIntegerScale() {
  // Use the largest integer scale factor that fits in the window
  const maxW = window.innerWidth;
  const maxH = window.innerHeight;

  // maximum integer scale for width and height
  const sW = Math.floor(maxW / GAME_W);
  const sH = Math.floor(maxH / GAME_H);

  // choose the largest integer >=1 that fits both
  scale = Math.max(1, Math.min(sW === 0 ? 1 : sW, sH === 0 ? 1 : sH));

  // If both sW and sH are zero (window smaller than native size), fall back to scale = 1 and allow cropping (or center)
  if (sW === 0 || sH === 0) {
    // If the window is smaller than native resolution, to avoid cropping we keep scale=1 but shrink the canvas to window size and let the browser clip.
    // However pixel-perfect scaling cannot show more pixels than fit, so we keep scale 1 and center.
    scale = 1;
  }

  destW = GAME_W * scale;
  destH = GAME_H * scale;
  destX = Math.round((window.innerWidth - destW) / 2);
  destY = Math.round((window.innerHeight - destH) / 2);

  // Set canvas element size to window inner size so it fills the page and leaves black bars in CSS background
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // Apply CSS size to be equal to pixel size to avoid browser scaling
  canvas.style.width = window.innerWidth + "px";
  canvas.style.height = window.innerHeight + "px";
}
window.addEventListener('resize', computeIntegerScale);
computeIntegerScale();

/* Asset paths (same as your C++ paths) */
const assetPaths = {
  player_idle:            "player/textures/idle/idle.png",
  player_run_1:           "player/textures/run/run_1.png",
  player_run_2:           "player/textures/run/run_2.png",
  player_run_3:           "player/textures/run/run_3.png",
  player_run_4:           "player/textures/run/run_4.png",
  player_run_5:           "player/textures/run/run_5.png",
  player_slide:           "player/textures/slide/slide.png",

  grappling_gun:          "guns/grappling gun/textures/grappling_gun.png",
  pistol_tex:             "guns/pistol/textures/pistol.png",

  ground:                 "ground/textures/ground.png",
  grappling_point:        "grappling points/textures/grappling_point.png",
  jump_pad:               "jump pads/textures/jump_pad.png"
};

const images = {};
let assetsToLoad = 0;
let assetsLoaded = 0;
const loadingEl = document.getElementById('loading');

function loadAssets(cb) {
  assetsToLoad = Object.keys(assetPaths).length;
  assetsLoaded = 0;
  for (const [key, path] of Object.entries(assetPaths)) {
    const img = new Image();
    img.src = path;
    img.onload = () => {
      images[key] = img;
      assetsLoaded++;
      loadingEl.textContent = "Loading assets... (" + assetsLoaded + "/" + assetsToLoad + ")";
      if (assetsLoaded === assetsToLoad) {
        loadingEl.style.display = 'none';
        cb();
      }
    };
    img.onerror = () => {
      // placeholder so the code doesn't break if missing
      const stub = document.createElement('canvas');
      stub.width = 64;
      stub.height = 64;
      const sg = stub.getContext('2d');
      sg.fillStyle = '#ff00ff';
      sg.fillRect(0,0,stub.width, stub.height);
      sg.fillStyle = '#000';
      sg.fillText('missing', 4, 12);
      images[key] = stub;
      assetsLoaded++;
      loadingEl.textContent = "Loading assets... (" + assetsLoaded + "/" + assetsToLoad + ")";
      if (assetsLoaded === assetsToLoad) {
        loadingEl.style.display = 'none';
        cb();
      }
    };
  }
}

/* Utility functions */
function rectIntersects(a,b){
  return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
}
function pointInRect(px,py, r){
  return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
}

/* Draw helpers */
function drawImageRot(img, x, y, w, h, angleDeg = 0, flip = 'none') {
  const cx = x + w/2, cy = y + h/2;
  g.save();
  g.translate(cx, cy);
  const rad = (angleDeg * Math.PI) / 180;
  g.rotate(rad);
  if (flip === 'horizontal') g.scale(-1, 1);
  if (flip === 'vertical')   g.scale(1, -1);
  g.drawImage(img, -w/2, -h/2, w, h);
  g.restore();
}
function drawImageFlipped(img, x, y, w, h, flip = 'none') {
  g.save();
  const cx = x + w/2, cy = y + h/2;
  g.translate(cx, cy);
  if (flip === 'horizontal') g.scale(-1, 1);
  if (flip === 'vertical')   g.scale(1, -1);
  g.drawImage(img, -w/2, -h/2, w, h);
  g.restore();
}

/* Game objects (same initial states) */
const player = {
  normal: { x: 0, y: 700, w: PLAYER_W, h: PLAYER_H },
  slide:  { x: 0, y: 704, w: 18 * 2, h: 21 * 2 },
  x_velocity: 0, y_velocity: 0, falling: 0, dir: 1,
  running: false, sliding: false, gun: "none", run_frame: 0
};

const grappling_gun = {
  rect: { x: 600, y: GAME_H - 64, w: 9 * 2, h: 7 * 2 },
  init_x: 0, init_y: 0, init_dist: 0, grapplerPos: {x:0,y:0},
  x_velocity: 0, y_velocity: 0, angle: 0, grappling: false
};

const pistol = {
  rect: { x: 700, y: GAME_H - 64, w: 9 * 2, h: 7 * 2 },
  x_velocity: 0, y_velocity: 0, angle: 0
};

const pistol_bullet = new Array(100).fill(null).map(() => ({
  active: false, x:0, y:0, dx:0, dy:0, rect:{x:0,y:0,w:10,h:10}
}));

const level = [
  { rect: { x: 0, y: GAME_H - 50, w: 2000, h: 200 } },
  { rect: { x: 0, y: GAME_H - 600, w: 2000, h: 200 } }
];

const grappling_points = [
  { rect: { x: 1000, y: GAME_H - 430, w: 60, h: 60 } }
];
for (const gp of grappling_points) {
  gp.hitbox = {
    x: gp.rect.x - (4 * gp.rect.w),
    y: gp.rect.y - (4 * gp.rect.h),
    w: gp.rect.w * 9,
    h: gp.rect.h * 9
  };
}

const jump_pads = [
  { rect: { x: 500, y: GAME_H - 62, w: 50, h: 12 } }
];

/* Input handling */
const keys = {};
let mouseIsDown = false;
let cursorScreenX = 0, cursorScreenY = 0;
let cursorX = 0, cursorY = 0; // in game native coordinates

window.addEventListener('keydown', (ev) => { keys[ev.code] = true; });
window.addEventListener('keyup',   (ev) => { keys[ev.code] = false; });

function updateCursorFromEvent(evt) {
  const rect = canvas.getBoundingClientRect();
  cursorScreenX = evt.clientX - rect.left;
  cursorScreenY = evt.clientY - rect.top;
  // Convert from screen pixel to game native coords using current integer scale and destX/destY.
  // If cursor is outside the game area, coordinates can be outside 0..GAME_W/GAME_H (consistent with C++).
  cursorX = (cursorScreenX - destX) / Math.max(scale, 1);
  cursorY = (cursorScreenY - destY) / Math.max(scale, 1);
  return { x: cursorX, y: cursorY };
}

canvas.addEventListener('mousemove', (ev) => { updateCursorFromEvent(ev); });
canvas.addEventListener('mousedown', (ev) => {
  updateCursorFromEvent(ev);
  if (player.gun === "grapple") {
    for (let i = 0; i < grappling_points.length; i++) {
      if (mouseIsDown === false) {
        const gp = grappling_points[i];
        if (pointInRect(cursorX, cursorY, gp.hitbox)) {
          grappling_gun.init_x = gp.rect.x + (gp.rect.w / 2);
          grappling_gun.init_y = gp.rect.y + (gp.rect.h / 2);
          grappling_gun.grapplerPos.x = grappling_gun.init_x;
          grappling_gun.grapplerPos.y = grappling_gun.init_y;
          const dx = grappling_gun.init_x - player.normal.x;
          const dy = grappling_gun.init_y - player.normal.y;
          grappling_gun.init_dist = Math.sqrt(dx*dx + dy*dy) / 2;
        } else {
          // replicate small bug from original: init_y set to cursorX
          grappling_gun.init_x = cursorX;
          grappling_gun.init_y = cursorX;
          grappling_gun.grapplerPos.x = grappling_gun.init_x;
          grappling_gun.grapplerPos.y = grappling_gun.init_y;
          const dx = grappling_gun.init_x - player.normal.x;
          const dy = grappling_gun.init_y - player.normal.y;
          grappling_gun.init_dist = Math.sqrt(dx*dx + dy*dy) / 2;
        }
      }
    }
  }
  mouseIsDown = true;
});
canvas.addEventListener('mouseup', (ev) => {
  updateCursorFromEvent(ev);
  if (player.gun === "grapple") {
    if (mouseIsDown === true && grappling_gun.grappling === true) player.x_velocity *= 2;
  }
  if (player.gun === "pistol") {
    if (mouseIsDown === true) {
      let used = false;
      for (let i = 0; i < pistol_bullet.length && !used; i++) {
        if (!pistol_bullet[i].active && !used) {
          pistol_bullet[i].active = true;
          pistol_bullet[i].x = pistol.rect.x;
          pistol_bullet[i].y = pistol.rect.y;
          pistol_bullet[i].rect.x = pistol.rect.x;
          pistol_bullet[i].rect.y = pistol.rect.y;

          // replicate C++ behavior
          pistol.rect.x = SCREEN_WM - 8;
          pistol.rect.y = SCREEN_HM;

          let dx = cursorX - pistol.rect.x;
          let dy = cursorY - pistol.rect.y;
          let distance = Math.sqrt(dx*dx + dy*dy);
          if (distance > 0) { dx /= distance; dy /= distance; }
          pistol_bullet[i].dx = dx;
          pistol_bullet[i].dy = dy;

          used = true;
        }
      }
    }
  }
  mouseIsDown = false;
});

// touch mapping
canvas.addEventListener('touchstart', (ev) => {
  ev.preventDefault();
  const t = ev.touches[0];
  updateCursorFromEvent({ clientX: t.clientX, clientY: t.clientY });
  if (player.gun === "grapple") {
    for (let i = 0; i < grappling_points.length; i++) {
      if (mouseIsDown === false) {
        const gp = grappling_points[i];
        if (pointInRect(cursorX, cursorY, gp.hitbox)) {
          grappling_gun.init_x = gp.rect.x + (gp.rect.w / 2);
          grappling_gun.init_y = gp.rect.y + (gp.rect.h / 2);
          grappling_gun.grapplerPos.x = grappling_gun.init_x;
          grappling_gun.grapplerPos.y = grappling_gun.init_y;
          const dx = grappling_gun.init_x - player.normal.x;
          const dy = grappling_gun.init_y - player.normal.y;
          grappling_gun.init_dist = Math.sqrt(dx*dx + dy*dy) / 2;
        } else {
          grappling_gun.init_x = cursorX;
          grappling_gun.init_y = cursorX;
          grappling_gun.grapplerPos.x = grappling_gun.init_x;
          grappling_gun.grapplerPos.y = grappling_gun.init_y;
          const dx = grappling_gun.init_x - player.normal.x;
          const dy = grappling_gun.init_y - player.normal.y;
          grappling_gun.init_dist = Math.sqrt(dx*dx + dy*dy) / 2;
        }
      }
    }
  }
  mouseIsDown = true;
});
canvas.addEventListener('touchend', (ev) => {
  ev.preventDefault();
  if (player.gun === "grapple") {
    if (mouseIsDown === true && grappling_gun.grappling === true) player.x_velocity *= 2;
  }
  if (player.gun === "pistol") {
    if (mouseIsDown === true) {
      let used = false;
      for (let i = 0; i < pistol_bullet.length && !used; i++) {
        if (!pistol_bullet[i].active && !used) {
          pistol_bullet[i].active = true;
          pistol_bullet[i].x = pistol.rect.x;
          pistol_bullet[i].y = pistol.rect.y;
          pistol_bullet[i].rect.x = pistol.rect.x;
          pistol_bullet[i].rect.y = pistol.rect.y;

          pistol.rect.x = SCREEN_WM - 8;
          pistol.rect.y = SCREEN_HM;

          let dx = cursorX - pistol.rect.x;
          let dy = cursorY - pistol.rect.y;
          let distance = Math.sqrt(dx*dx + dy*dy);
          if (distance > 0) { dx /= distance; dy /= distance; }
          pistol_bullet[i].dx = dx;
          pistol_bullet[i].dy = dy;

          used = true;
        }
      }
    }
  }
  mouseIsDown = false;
});

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

/* Main game loop (mirrors main.cpp) */
let lastTime = performance.now();

function gameLoop(now) {
  const dt = now - lastTime;
  lastTime = now;

  // Input: mirror SDL_GetKeyboardState logic
  if (mouseIsDown === false || grappling_gun.grappling === false) {
    if (!player.sliding) {
      if (keys['KeyA']) { player.x_velocity -= ACCELERATION; player.dir = -1; }
      if (keys['KeyD']) { player.x_velocity += ACCELERATION; player.dir =  1; }
      if (keys['KeyW'] && player.falling <= 2) { player.y_velocity = -12; }

      if (keys['KeyA'] || keys['KeyD']) { player.run_frame += 0.2; player.running = true; }
    }
    player.sliding = !!keys['KeyS'];

    if (keys['KeyQ'] && player.gun === "grapple") {
      player.gun = "none";
      const dx = cursorX - grappling_gun.rect.x;
      const dy = cursorY - grappling_gun.rect.y;
      grappling_gun.x_velocity = dx / 6;
      grappling_gun.y_velocity = dy / 6;
    }
    if (keys['KeyQ'] && player.gun === "pistol") {
      player.gun = "none";
      const dx = cursorX - pistol.rect.x;
      const dy = cursorY - pistol.rect.y;
      pistol.x_velocity = dx / 6;
      pistol.y_velocity = dy / 6;
    }

    if (keys['KeyE']) {
      if (pointInRect(cursorX, cursorY, grappling_gun.rect) &&
          Math.abs(player.normal.x - grappling_gun.rect.x) < 500 &&
          Math.abs(player.normal.y - grappling_gun.rect.y) < 500) player.gun = "grapple";
      if (pointInRect(cursorX, cursorY, pistol.rect) &&
          Math.abs(player.normal.x - pistol.rect.x) < 500 &&
          Math.abs(player.normal.y - pistol.rect.y) < 500) player.gun = "pistol";
    }
  }

  // --- Update objects ---
  grappling_gun.grappling = false;
  if (player.gun === "grapple") {
    for (let i = 0; i < grappling_points.length; i++) {
      const gp = grappling_points[i];
      if (mouseIsDown && pointInRect(grappling_gun.grapplerPos.x, grappling_gun.grapplerPos.y, gp.hitbox)) {
        grappling_gun.grappling = true;
        let dx = grappling_gun.init_x - player.normal.x;
        let dy = grappling_gun.init_y - player.normal.y;
        let distance = Math.sqrt(dx*dx + dy*dy);
        if (distance !== 0) { dx /= distance; dy /= distance; }
        player.x_velocity += dx * 3;
        if (distance < grappling_gun.init_dist) player.y_velocity -= dy;
        else player.y_velocity += dy * 2;
      }
    }
  } else {
    if (Math.abs(grappling_gun.x_velocity) < 0.5) grappling_gun.x_velocity = 0;
    grappling_gun.x_velocity *= 0.95;
    grappling_gun.y_velocity += 1;

    if (grappling_gun.x_velocity !== 0) {
      const steps = Math.ceil(Math.abs(grappling_gun.x_velocity));
      for (let i = 0; i < steps; i++) {
        const lastX = grappling_gun.rect.x;
        const sign = grappling_gun.x_velocity / Math.abs(grappling_gun.x_velocity);
        grappling_gun.rect.x += sign;
        let collided = false;
        for (let j = 0; j < level.length; j++) if (rectIntersects(grappling_gun.rect, level[j].rect)) { collided = true; break; }
        if (!collided) for (let j = 0; j < jump_pads.length; j++) if (rectIntersects(grappling_gun.rect, jump_pads[j].rect)) { collided = true; break; }
        if (collided) { grappling_gun.rect.x = lastX; grappling_gun.x_velocity = 0; }
      }
    }

    if (grappling_gun.y_velocity !== 0) {
      const steps = Math.ceil(Math.abs(grappling_gun.y_velocity));
      for (let i = 0; i < steps; i++) {
        const lastY = grappling_gun.rect.y;
        const sign = grappling_gun.y_velocity / Math.abs(grappling_gun.y_velocity);
        grappling_gun.rect.y += sign;
        let collided = false;
        for (let j = 0; j < level.length; j++) if (rectIntersects(grappling_gun.rect, level[j].rect)) { collided = true; break; }
        if (!collided) {
          for (let j = 0; j < jump_pads.length; j++) {
            if (rectIntersects(grappling_gun.rect, jump_pads[j].rect)) {
              collided = true;
              grappling_gun.y_velocity = -15;
              break;
            }
          }
        }
        if (collided === true && grappling_gun.y_velocity !== -15) {
          grappling_gun.rect.y = lastY;
          grappling_gun.y_velocity = 0;
        }
      }
    }
  }

  // Pistol physics when not held
  if (player.gun !== "pistol") {
    if (Math.abs(pistol.x_velocity) < 0.5) pistol.x_velocity = 0;
    pistol.x_velocity *= 0.95;
    pistol.y_velocity += 1;

    if (pistol.x_velocity !== 0) {
      const steps = Math.ceil(Math.abs(pistol.x_velocity));
      for (let i = 0; i < steps; i++) {
        const lastX = pistol.rect.x;
        const sign = pistol.x_velocity / Math.abs(pistol.x_velocity);
        pistol.rect.x += sign;
        let collided = false;
        for (let j = 0; j < level.length; j++) if (rectIntersects(pistol.rect, level[j].rect)) { collided = true; break; }
        if (!collided) for (let j = 0; j < jump_pads.length; j++) if (rectIntersects(pistol.rect, jump_pads[j].rect)) { collided = true; break; }
        if (collided) { pistol.rect.x = lastX; pistol.x_velocity = 0; }
      }
    }

    if (pistol.y_velocity !== 0) {
      const steps = Math.ceil(Math.abs(pistol.y_velocity));
      for (let i = 0; i < steps; i++) {
        const lastY = pistol.rect.y;
        const sign = pistol.y_velocity / Math.abs(pistol.y_velocity);
        pistol.rect.y += sign;
        let collided = false;
        for (let j = 0; j < level.length; j++) if (rectIntersects(pistol.rect, level[j].rect)) { collided = true; break; }
        if (!collided) {
          for (let j = 0; j < jump_pads.length; j++) {
            if (rectIntersects(pistol.rect, jump_pads[j].rect)) {
              collided = true;
              pistol.y_velocity = -15;
              break;
            }
          }
        }
        if (collided === true && pistol.y_velocity !== -15) {
          pistol.rect.y = lastY;
          pistol.y_velocity = 0;
        }
      }
    }
  }

  // Player physics
  player.falling++;
  player.y_velocity += GRAVITY;
  if (!player.sliding) player.x_velocity *= FRICTION;

  if (Math.abs(player.x_velocity) < 0.1) {
    player.x_velocity = 0;
    player.running = false;
    player.run_frame = 0;
  }
  if (!(keys['KeyA'] || keys['KeyD']) && Math.abs(player.x_velocity) > 0) player.run_frame += 0.1;

  // Player X collision
  if (player.x_velocity !== 0) {
    const steps = Math.ceil(Math.abs(player.x_velocity));
    for (let i = 0; i < steps; i++) {
      const lastX = player.normal.x;
      const sign = player.x_velocity / Math.abs(player.x_velocity);
      player.normal.x += sign;
      let collided = false;
      for (let j = 0; j < level.length; j++) if (rectIntersects(player.normal, level[j].rect)) { collided = true; break; }
      if (!collided) for (let j = 0; j < jump_pads.length; j++) if (rectIntersects(player.normal, jump_pads[j].rect)) { collided = true; break; }
      if (collided) { player.normal.x = lastX; player.x_velocity = 0; }
    }
  }

  // Player Y collision
  if (player.y_velocity !== 0) {
    const steps = Math.ceil(Math.abs(player.y_velocity));
    for (let i = 0; i < steps; i++) {
      const lastY = player.normal.y;
      const sign = player.y_velocity / Math.abs(player.y_velocity);
      player.normal.y += sign;
      let collided = false;
      for (let j = 0; j < level.length; j++) {
        if (rectIntersects(player.normal, level[j].rect)) {
          collided = true;
          player.falling = 0;
          player.y_velocity = 0;
          break;
        }
      }
      if (!collided) {
        for (let j = 0; j < jump_pads.length; j++) {
          if (rectIntersects(player.normal, jump_pads[j].rect)) {
            collided = true;
            player.falling = 0;
            player.y_velocity = -15;
            break;
          }
        }
      }
      if (collided === false) {
        // nothing
      } else {
        if (player.y_velocity === 0) player.normal.y = lastY;
      }
    }
  }

  // GrapplingGun when held
  if (player.gun === "grapple") {
    grappling_gun.rect.x = SCREEN_WM - 8;
    grappling_gun.rect.y = SCREEN_HM;
    let dx = cursorX - grappling_gun.rect.x;
    let dy = cursorY - grappling_gun.rect.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > 0) { dx/=dist; dy/=dist; }
    grappling_gun.rect.x += dx * 30;
    grappling_gun.rect.y += dy * 30;
  }

  // Pistol when held
  if (player.gun === "pistol") {
    pistol.rect.x = SCREEN_WM - 8;
    pistol.rect.y = SCREEN_HM;
    let dx = cursorX - pistol.rect.x;
    let dy = cursorY - pistol.rect.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > 0) { dx/=dist; dy/=dist; }
    pistol.rect.x += dx * 30;
    pistol.rect.y += dy * 30;

    for (let i = 0; i < pistol_bullet.length; i++) {
      if (pistol_bullet[i].active) {
        pistol_bullet[i].x += pistol_bullet[i].dx * 10;
        pistol_bullet[i].y += pistol_bullet[i].dy * 10;
        pistol_bullet[i].rect.x = pistol_bullet[i].x;
        pistol_bullet[i].rect.y = pistol_bullet[i].y;
      }
    }
  }

  // Scrolling mechanic
  const scrollX = player.normal.x - (SCREEN_WM - (PLAYER_W / 2));
  const scrollY = player.normal.y - (SCREEN_HM - (PLAYER_H / 2));

  player.normal.x = (SCREEN_WM - (PLAYER_W / 2));
  player.normal.y = (SCREEN_HM - (PLAYER_H / 2));
  grappling_gun.init_x -= scrollX;
  grappling_gun.init_y -= scrollY;
  grappling_gun.grapplerPos.x = grappling_gun.init_x;
  grappling_gun.grapplerPos.y = grappling_gun.init_y;

  player.slide.x = player.normal.x;
  player.slide.y = player.normal.y + 4;

  if (player.gun !== "grapple") {
    grappling_gun.rect.x -= scrollX;
    grappling_gun.rect.y -= scrollY;
  }
  if (player.gun !== "pistol") {
    pistol.rect.x -= scrollX;
    pistol.rect.y -= scrollY;
  }

  for (let i = 0; i < level.length; i++) {
    level[i].rect.x -= scrollX;
    level[i].rect.y -= scrollY;
  }
  for (let i = 0; i < grappling_points.length; i++) {
    grappling_points[i].rect.x -= scrollX;
    grappling_points[i].rect.y -= scrollY;
    grappling_points[i].hitbox.x -= scrollX;
    grappling_points[i].hitbox.y -= scrollY;
  }
  for (let i = 0; i < jump_pads.length; i++) {
    jump_pads[i].rect.x -= scrollX;
    jump_pads[i].rect.y -= scrollY;
  }

  // --- Rendering to offscreen buffer at native resolution ---
  g.fillStyle = 'rgb(0,0,255)';
  g.fillRect(0,0,GAME_W,GAME_H);

  // Draw grappling line (mirror DrawLine)
  function drawGrappleLine(p_dir) {
    if (!grappling_gun.grappling) return;
    const sx = grappling_gun.rect.x;
    const sy = grappling_gun.rect.y + 5;
    const tx = grappling_gun.init_x;
    const ty = grappling_gun.init_y;
    g.lineWidth = 1;
    function line(offA, offB, a) {
      g.strokeStyle = `rgba(83,185,255,${a})`;
      g.beginPath();
      g.moveTo(sx + offA, sy);
      g.lineTo(tx + offB, ty);
      g.stroke();
    }
    if (p_dir === 1) {
      line(-1,-3,0.27); line(0,-2,0.39); line(1,-1,0.59); line(2,0,0.7);
      line(3,0,1.0); line(4,1,1.0); line(5,2,1.0); line(6,3,1.0);
      line(7,4,0.7); line(8,5,0.59); line(9,6,0.39); line(10,7,0.27);
    } else {
      line(6,-3,0.27); line(7,-2,0.39); line(8,-1,0.59); line(9,0,0.7);
      line(10,0,1.0); line(11,1,1.0); line(12,2,1.0); line(13,3,1.0);
      line(14,4,0.7); line(15,5,0.59); line(16,6,0.39); line(17,7,0.27);
    }
  }
  drawGrappleLine(player.dir);

  // Draw grappling points
  for (let i = 0; i < grappling_points.length; i++) {
    const gp = grappling_points[i];
    if (images.grappling_point) g.drawImage(images.grappling_point, gp.rect.x, gp.rect.y, gp.rect.w, gp.rect.h);
    else { g.fillStyle='#0ff'; g.fillRect(gp.rect.x, gp.rect.y, gp.rect.w, gp.rect.h); }
  }

  // Draw jump pads
  for (let i = 0; i < jump_pads.length; i++) {
    const jp = jump_pads[i];
    if (images.jump_pad) g.drawImage(images.jump_pad, jp.rect.x, jp.rect.y, jp.rect.w, jp.rect.h);
    else { g.fillStyle='#ff0'; g.fillRect(jp.rect.x, jp.rect.y, jp.rect.w, jp.rect.h); }
  }

  // Draw ground
  for (let i = 0; i < level.length; i++) {
    if (images.ground) g.drawImage(images.ground, level[i].rect.x, level[i].rect.y, level[i].rect.w, level[i].rect.h);
    else { g.fillStyle='#550'; g.fillRect(level[i].rect.x, level[i].rect.y, level[i].rect.w, level[i].rect.h); }
  }

  // Draw player
  function drawPlayer() {
    if (!player.sliding) {
      if (player.dir === 1) {
        if (player.running) {
          const temp = Math.abs(Math.floor(player.run_frame));
          const frame = (temp % 5) + 1;
          const key = 'player_run_' + frame;
          const img = images[key] || images.player_idle;
          g.drawImage(img, player.normal.x, player.normal.y, player.normal.w, player.normal.h);
        } else {
          const img = images.player_idle;
          g.drawImage(img, player.normal.x, player.normal.y, player.normal.w, player.normal.h);
        }
      } else {
        if (player.running) {
          const temp = Math.abs(Math.floor(player.run_frame));
          const frame = (temp % 5) + 1;
          const key = 'player_run_' + frame;
          const img = images[key] || images.player_idle;
          drawImageFlipped(img, player.normal.x, player.normal.y, player.normal.w, player.normal.h, 'horizontal');
        } else {
          const img = images.player_idle;
          drawImageFlipped(img, player.normal.x, player.normal.y, player.normal.w, player.normal.h, 'horizontal');
        }
      }
    } else {
      if (player.dir === 1) {
        const img = images.player_slide;
        g.drawImage(img, player.slide.x, player.slide.y, player.slide.w, player.slide.h);
      } else {
        const img = images.player_slide;
        drawImageFlipped(img, player.slide.x, player.slide.y, player.slide.w, player.slide.h, 'horizontal');
      }
    }
  }
  drawPlayer();

  // Draw grappling gun
  function drawGrapplingGun() {
    if (player.gun === "grapple") {
      if (player.dir === 1) {
        if (grappling_gun.grappling === true) {
          const centerX = grappling_gun.rect.x + grappling_gun.rect.w / 2;
          const centerY = grappling_gun.rect.y + grappling_gun.rect.h / 2;
          const dx = grappling_gun.init_x - centerX;
          const dy = grappling_gun.init_y - centerY;
          const angle = Math.atan2(dy, dx) * (180.0 / Math.PI);
          grappling_gun.angle = angle;
          drawImageRot(images.grappling_gun, grappling_gun.rect.x, grappling_gun.rect.y, grappling_gun.rect.w, grappling_gun.rect.h, grappling_gun.angle, 'none');
        } else {
          const centerX = grappling_gun.rect.x + grappling_gun.rect.w / 2;
          const centerY = grappling_gun.rect.y + grappling_gun.rect.h / 2;
          const dx = cursorX - centerX;
          const dy = cursorY - centerY;
          const angle = Math.atan2(dy, dx) * (180.0 / Math.PI);
          if (Math.abs(grappling_gun.angle - angle) < 160) {
            if (grappling_gun.angle > angle) grappling_gun.angle -= (grappling_gun.angle - angle) / 6;
            else grappling_gun.angle += (angle - grappling_gun.angle) / 6;
          } else grappling_gun.angle = angle;
          drawImageRot(images.grappling_gun, grappling_gun.rect.x, grappling_gun.rect.y, grappling_gun.rect.w, grappling_gun.rect.h, grappling_gun.angle, 'none');
        }
      } else {
        if (grappling_gun.grappling === true) {
          const centerX = grappling_gun.rect.x + grappling_gun.rect.w / 2;
          const centerY = grappling_gun.rect.y + grappling_gun.rect.h / 2;
          const dx = grappling_gun.init_x - centerX;
          const dy = grappling_gun.init_y - centerY;
          const angle = Math.atan2(dy, dx) * (180.0 / Math.PI);
          grappling_gun.angle = angle;
          drawImageRot(images.grappling_gun, grappling_gun.rect.x, grappling_gun.rect.y, grappling_gun.rect.w, grappling_gun.rect.h, grappling_gun.angle, 'vertical');
        } else {
          const centerX = grappling_gun.rect.x + grappling_gun.rect.w / 2;
          const centerY = grappling_gun.rect.y + grappling_gun.rect.h / 2;
          const dx = cursorX - centerX;
          const dy = cursorY - centerY;
          const angle = Math.atan2(dy, dx) * (180.0 / Math.PI);
          if (Math.abs(grappling_gun.angle - angle) < 160) {
            if (grappling_gun.angle > angle) grappling_gun.angle -= (grappling_gun.angle - angle) / 6;
            else grappling_gun.angle += (angle - grappling_gun.angle) / 6;
          } else grappling_gun.angle = angle;
          drawImageRot(images.grappling_gun, grappling_gun.rect.x, grappling_gun.rect.y, grappling_gun.rect.w, grappling_gun.rect.h, grappling_gun.angle, 'vertical');
        }
      }
    } else {
      g.drawImage(images.grappling_gun, grappling_gun.rect.x, grappling_gun.rect.y, grappling_gun.rect.w, grappling_gun.rect.h);
    }
  }
  drawGrapplingGun();

  // Draw pistol
  function drawPistol() {
    if (player.gun === "pistol") {
      if (player.dir === 1) {
        const centerX = pistol.rect.x + pistol.rect.w / 2;
        const centerY = pistol.rect.y + pistol.rect.h / 2;
        let dx = cursorX - centerX;
        let dy = cursorY - centerY;
        let angle = Math.atan2(dy, dx) * (180.0 / Math.PI);
        if (Math.abs(pistol.angle - angle) < 160) {
          if (pistol.angle > angle) pistol.angle -= (pistol.angle - angle) / 6;
          else pistol.angle += (angle - pistol.angle) / 6;
        } else pistol.angle = angle;
        drawImageRot(images.pistol_tex, pistol.rect.x, pistol.rect.y, pistol.rect.w, pistol.rect.h, pistol.angle, 'none');
      } else {
        const centerX = pistol.rect.x + pistol.rect.w / 2;
        const centerY = pistol.rect.y + pistol.rect.h / 2;
        let dx = cursorX - centerX;
        let dy = cursorY - centerY;
        let angle = Math.atan2(dy, dx) * (180.0 / Math.PI);
        if (Math.abs(pistol.angle - angle) < 160) {
          if (pistol.angle > angle) pistol.angle -= (pistol.angle - angle) / 6;
          else pistol.angle += (angle - pistol.angle) / 6;
        } else pistol.angle = angle;
        drawImageRot(images.pistol_tex, pistol.rect.x, pistol.rect.y, pistol.rect.w, pistol.rect.h, pistol.angle, 'vertical');
      }
    } else {
      g.drawImage(images.pistol_tex, pistol.rect.x, pistol.rect.y, pistol.rect.w, pistol.rect.h);
    }
  }
  drawPistol();

  // Draw bullets
  for (let i = 0; i < pistol_bullet.length; i++) {
    if (pistol_bullet[i].active) {
      const b = pistol_bullet[i].rect;
      g.drawImage(images.pistol_tex, b.x, b.y, b.w, b.h);
    }
  }

  // --- Present buffer scaled by integer factor, centered with black bars ---
  // Clear the visible canvas (black)
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.width, canvas.height);

  // Recompute integer scale in case window changed since last frame
  computeIntegerScale();

  // Ensure nearest-neighbor for final draw
  disableSmoothing(ctx);

  // Destination rectangle is destX,destY,destW,destH (already integral)
  ctx.drawImage(buffer, 0, 0, GAME_W, GAME_H, destX, destY, destW, destH);

  window.requestAnimationFrame(gameLoop);
}

/* Start */
loadAssets(() => {
  // fallback mapping
  images.player_run_1 = images.player_run_1 || images.player_idle;
  images.player_run_2 = images.player_run_2 || images.player_idle;
  images.player_run_3 = images.player_run_3 || images.player_idle;
  images.player_run_4 = images.player_run_4 || images.player_idle;
  images.player_run_5 = images.player_run_5 || images.player_idle;

  lastTime = performance.now();
  window.requestAnimationFrame(gameLoop);
});
</script>
</body>
</html>